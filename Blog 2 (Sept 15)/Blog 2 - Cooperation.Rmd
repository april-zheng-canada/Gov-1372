---
title: 'Data Exploration: Cooperation'
author: "April Zheng"
date: "September 15, 2025"
output:
  pdf_document: default
  html_document:
    df_print: paged
urlcolor: blue
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

# check for required packages and install if not already
list.of.packages <- c("tools", "roxygen2", "shiny", "dplyr", "ggvis", "progress")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[, "Package"])]
if (length(new.packages)) install.packages(new.packages)

# load libraries
library(tools) # needed for shiny app
library(readr) # read_csv()
library(dplyr) # dplyr()
library(ggplot2) # ggplot()

# source helper files for the prisoner's dilemma app
source("./axelRod-master/R/shiny_tournament.R")
source("./axelRod-master/R/fn.R")
source("./axelRod-master/R/Tournament.R")
source("./axelRod-master/R/Player.R")
source("./axelRod-master/R/zzz.R")

```


# The Evolution of Cooperation

Axelrod's \textit{Evolution of Cooperation} uses the construct of the Prisoner's Dilemma to illustrate how cooperation can emerge despite incentives not to. In the Prisoner's Dilemma game, players must choose whether to cooperate or defect. The payoffs for doing one or the other depend on what the other player does, but no matter if the other player cooperates or defects, it is always strictly better for players to defect. 

This can be seen in the table below, which replicates the game Axelrod uses throughout his book. If player 2 cooperates, it's better for player 1 to defect, since then player 1 would receive 5 points instead of 3. If player 2 defects, player 1 definitely wants to defect and receive 1 point rather than 0. So no matter what each player expects the other to do, they will both choose to defect, yielding 1 point to each player.

\begin{center}
\begin{tabular}{ | c | c | c | } 
\hline
P1 $\downarrow$; P2 $\rightarrow$ & C & D \\ 
\hline
C & R = 3, R = 3 & S = 0, T = 5 \\ 
\hline
D & T = 5, S = 0 & P = 1, P = 1 \\ 
\hline
\end{tabular}
\end{center}

But ideally, in the long run (in a repeated game) players would like to cooperate and receive 3 points on each round. Axelrod explains how strategies of cooperation can evolve even in circumstances where players are antagonists (like Allied and Axis soldiers in the trenches of World War I) or when the players are not capable of foresight (as is the case for cooperation in biological systems).

# The Prisoner's Dilemma Simulator

For this week's Data Exploration assignment, you will be working with a Shiny app that simulates prisoner's dilemma games. To use it, simply run the code chunk above labeled 'setup', then run the following code (`shiny_tournament()`). Doing so will open the app in a separate window.

P.S., the "Instructions" tab in the app is broken. Don't worry if it doesn't display anything for you. Refer to this document for instructions. 

P.P.S., when you close the app window, there may be some warnings or errors (like "no loop for break/next, jumping to top level"). You can just ignore them.

```{r, include = F, message = F}

shiny_tournament()

```

## Setup

Now we're going to do a round-robin style tournament between strategies of your choosing, similar to the ones Axelrod conducted. All students must complete this part, as the subsequent questions are based on the tournament you conduct here. 

**First**, choose at least 6 strategies from the menu that look interesting to you. Your task is to play each one against all the other opponents and record the results in the excel file available in the Google Drive called `prisoners_dilemma_data.xlsx`.

**Second**, once you have chosen your strategies, type all the pairwise combinations of those strategies into the columns `player1` and `player2`. Make sure you type the strategies exactly as they appear in the application, including the case of the letters! Your spreadsheet should look this like after you have done so (but with the strategies you choose):

![This is what your table should look like after step 2.](./rmd_photos/step2.png)

Note that there are 15 ways to combine 6 elements into pairs\footnote{In math terms, this results from the fact that ${6 \choose 2} = 15$}, so if you don't have 15 pairs, check your work.  Also note that the more strategies you choose, the more typing you will have to do.

You can use the `pair_combs()` function that the TF team made to see what should be included in your 15 combinations. Below, make sure to change the "strat1", "strat2", ..., "strat6" to the 6 strategies that you have chosen.
```{r combinations}
source("combinations_helper.R")

pair_combs(c("strat1", "strat2", "strat3", "strat4", "strat5", "strat6"))
```

**Third**, set the app so that "Tournament Type" = "Repeated", "Number of Rounds" = 100, and "Number of Replications" = 100. Just as in Axelrod's simulation, we are playing repeated games (this is determined by the "Number of Rounds"). The "Number of Replications" changes how many times the computer plays each repeated game. So in the example above, the computer will repeat the 100-round game of titfortat vs. inverser 100 times over and take the average outcome of each of those replications. This is useful because some of the strategies rely on probability (e.g. play "Defect" with probability .5) and so the outcome will be different each time. We average over many outcomes to see which strategy wins on average. Once you're done, your spreadsheet should look something like this, but with different strategies:

![This is what your table should look like after step 3.](./rmd_photos/step3.png)


Of course, don't just copy these numbers, since they're made up.

**Fourth**, save the file as a CSV. To do so, go to File > Save As, then set the File Format to be `CSV UTF-8 (Comma delimited) (.csv)`. Make sure to save it with the name `prisoners_dilemma_data.csv`.


Now you can finally read the data you created into R using the following code and start answering the questions that follow.
```{r}

pd_data <- read_csv("prisoners_dilemma_data.csv") |> 
  mutate(winner = case_when( # if you are interested, case_when() is a very useful
    score1 > score2 ~ player1, # function to create new variables. check out how it
    score1 < score2 ~ player2, # works by googling.
    score1 == score2 ~ "tie"
  ))

```

## Question 1

**How do the strategies you chose rank against each other based on the number of wins? How do they rank based on the number of points won? Discuss the patterns you see here as they relate to what you read from Axelrod. Keep in mind the concepts of niceness, retaliation, forgiveness, and clarity.**

The following code makes a data frame called `player_data_long` that you can use to rank the strategies based on the number of points won during the tournament. As a hint, you may want to try using `group_by()`, `summarize()`, and `arrange()` on `player_data_long`.

If you want, try to figure out what each line of code does. Cleaning the data and rearranging it like this is an important part of data science, not just running regressions and taking means. This is why we are leaving some of it to you, via `group_by()` and `summarize()`.

```{r}

player1_data <- pd_data |> select(player = player1, score = score1, opponent = player2)
player2_data <- pd_data |> select(player = player2, score = score2, opponent = player1)
player_data_long <- bind_rows(player1_data, player2_data)

```

To rank the strategies based on the number of wins, think about making use of the `winner` variable in the `pda_data` data frame.


```{r}
#First read the data file with tournament results - files always csv!!
tournament_data <- read_csv("prisoners_dilemma_data.csv") 

#We've reduced the table down from 4 columns to 2 columns (just the player, and their score) - so reduced the specificity because this will allow us to then add up all the different scores together. This new table is called player_data_overall (<- means assigning something to that variable)
player_data_overall <- bind_rows( 
  tournament_data|>select(player = player1, score = score1),
  tournament_data|>select(player = player2, score = score2)
  )
  
#now, calculate total scores for each player and sort in descending order. This new table is called points_ranking. 
  points_ranking <- player_data_overall |> 
    group_by(player) |>
  summarize(total_score = sum(score)) |>
  arrange(desc(total_score))

#dont forget to print. 
print(points_ranking)
```


```{r}
# Add a winner column to each game - and we're determining what is a winner
games_with_winners <- tournament_data |>
  mutate(
    winner = case_when(
      score1 > score2 ~ player1,  # player1 wins if score1 is higher
      score2 > score1 ~ player2,  # player2 wins if score2 is higher
      score1 == score2 ~ "Tie"    
    )
  )

# Count wins for each player 
wins_ranking <- games_with_winners |>
  count(winner, name = "total_wins") |>
  arrange(desc(total_wins))       # Sort 

print(wins_ranking)
```



